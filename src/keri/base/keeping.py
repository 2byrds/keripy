# -*- encoding: utf-8 -*-
"""
KERI
keri.base.keeping module

txn.put(
            did.encode(),
            json.dumps(certifiable_data).encode("utf-8")
        )
raw_data = txn.get(did.encode())
    if raw_data is None:
        return None
    return json.loads(raw_data)

ked = json.loads(raw[:size].decode("utf-8"))
raw = json.dumps(ked, separators=(",", ":"), ensure_ascii=False).encode("utf-8")

"""
import os
import stat

from hio.base import doing

from .. import kering
from ..db import dbing


def ppKey(pre, pub):
    """
    Returns bytes for DB key from concatenation of qualified Base64:
    pre is identifier prefix bytes or str
    pub is  public key bytes or str
    If pre or pub are str then converts to bytes
    """
    if hasattr(pre, "encode"):
        pre = pre.encode("utf-8")  # convert str to bytes
    if hasattr(pub, "encode"):
        pub = pub.encode("utf-8")  # convert str to bytes

    return (b'%s.%s' %  (pre, pub))


def ixKey(pre, idx):
    """
    Returns bytes for DB key from concatenation of qualified Base64:
    pre is identifier prefix bytes or str
        If pre is str then converts to bytes
    idx is index int this is converted to 32 char hex string
    """
    if hasattr(pre, "encode"):
        pre = pre.encode("utf-8")  # convert str to bytes
    return (b'%s.%032x' % (pre, idx))


def openKeep(name="test", **kwa):
    """
    Returns contextmanager generated by openLMDB but with Keeper instance
    """
    return dbing.openLMDB(cls=Keeper, name=name, **kwa)


class Keeper(dbing.LMDBer):
    """
    Keeper sets up named sub databases for key pair storage.  Methods provide
    key pair creation and data signing.

    Attributes:
        see superclass LMDBer for inherited attributes

        .keys is named sub DB whose values are private keys
            Keyed by public key (fully qualified qb64)
            Value is private key (fully qualified qb64)

        .prms is named sub DB whose values are serialized dicts
            Keyed by identifer prefix (fully qualified qb64)
            Value is  serialized parameter dict (JSON)
                {sgn: { ridx:, kidx, len:}, nxt: {ridx:,kidx:,len:}}

        .idxs is named sub DB whose values are serialized dicts
            Use ppKey() for key
            Keyed by pre.pub where pre is identifier prefix and pub is public key
                both fully qualified qb64
            Value is serialized data dict (JSON)
                {ridx:, kidx:,dt:} where dt is ISO 8601 format datetime
                nowIso8601() when keypair first created

        .pubs is named sub DB whose values are public keys
            Use ixKey() for key
            Keyed by pre.idx where pre is identifier prefix (qb64) and idx is
                kidx, is key index in sequence of key pair for prefix. idx is
                integer converted to 32 char hex str bytes for key.
            Value is public key (fully qualified qb64) at kidx

        .rots is named sub DB whose values are serialized dicts
            Use ixKey() for key
            Keyed by pre.idx where pre is identifier prefix (qb64) and idx is
                ridx, is rotation index in sequence of rotation for prefix. idx is
                integer converted to 32 char hex str bytes for key.
            Value is serialized data dict (JSON)
                {kidx:,len:}  where kidx is key index of starting key in rotation
                set and line is number of keys in rotation set.


    Properties:


    Directory Mode for Restricted Access Permissions
    stat.S_ISVTX  is Sticky bit. When this bit is set on a directory it means
        that a file in that directory can be renamed or deleted only by the
        owner of the file, by the owner of the directory, or by a privileged process.

    stat.S_IRUSR Owner has read permission.
    stat.S_IWUSR Owner has write permission.
    stat.S_IXUSR Owner has execute permission.
    """
    HeadDirPath = "/usr/local/var"  # default in /usr/local/var
    TailDirPath = "keri/keep"
    AltHeadDirPath = "~"  #  put in ~ as fallback when desired not permitted
    AltTailDirPath = ".keri/keep"
    TempHeadDir = "/tmp"
    TempPrefix = "keri_keep_"
    TempSuffix = "_test"
    MaxNamedDBs = 8
    DirMode = stat.S_ISVTX | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR  # 0o1700

    def __init__(self, headDirPath=None, dirMode=None, reopen=True, **kwa):
        """
        Setup named sub databases.

        Inherited Parameters:
            name is str directory path name differentiator for main database
                When system employs more than one keri database, name allows
                differentiating each instance by name
                default name='main'
            temp is boolean, assign to .temp
                True then open in temporary directory, clear on close
                Othewise then open persistent directory, do not clear on close
                default temp=False
            headDirPath is optional str head directory pathname for main database
                If not provided use default .HeadDirpath
                default headDirPath=None so uses self.HeadDirPath
            dirMode is numeric optional os dir permissions mode
                default dirMode=None so do not set mode
            reopen is boolean, IF True then database will be reopened by this init
                default reopen=True

        Notes:

        dupsort=True for sub DB means allow unique (key,pair) duplicates at a key.
        Duplicate means that is more than one value at a key but not a redundant
        copies a (key,value) pair per key. In other words the pair (key,value)
        must be unique both key and value in combination.
        Attempting to put the same (key,value) pair a second time does
        not add another copy.

        Duplicates are inserted in lexocographic order by value, insertion order.

        """
        if dirMode is None:
            dirMode = self.DirMode  # defaults to restricted permissions for non temp

        super(Keeper, self).__init__(headDirPath=headDirPath, dirMode=dirMode,
                                     reopen=reopen, **kwa)



    def reopen(self, **kwa):
        """
        Open sub databases
        """
        super(Keeper, self).reopen(**kwa)

        # Create by opening first time named sub DBs within main DB instance
        # Names end with "." as sub DB name must include a non Base64 character
        # to avoid namespace collisions with Base64 identifier prefixes.


        self.keys = self.env.open_db(key=b'keys.')
        self.prms = self.env.open_db(key=b'prms.')
        self.idxs = self.env.open_db(key=b'idxs.')
        self.pubs = self.env.open_db(key=b'pubs.')
        self.rots = self.env.open_db(key=b'rots.')




class KeeperDoer(doing.Doer):
    """
    Basic Keeper Doer ( LMDB Database )

    Inherited Attributes:
        .done is Boolean completion state:
            True means completed
            Otherwise incomplete. Incompletion maybe due to close or abort.

    Attributes:
        .keeper is Keeper or LMDBer subclass

    Inherited Properties:
        .tyme is float ._tymist.tyme, relative cycle or artificial time
        .tock is float, desired time in seconds between runs or until next run,
                 non negative, zero means run asap

    Properties:

    Methods:
        .wind  injects ._tymist dependency
        .__call__ makes instance callable
            Appears as generator function that returns generator
        .do is generator method that returns generator
        .enter is enter context action method
        .recur is recur context action method or generator method
        .exit is exit context method
        .close is close context method
        .abort is abort context method

    Hidden:
       ._tymist is Tymist instance reference
       ._tock is hidden attribute for .tock property
    """

    def __init__(self, keeper, **kwa):
        """
        Inherited Parameters:
           tymist is Tymist instance
           tock is float seconds initial value of .tock

        Parameters:
           keeper is Keeper instance
        """
        super(KeeperDoer, self).__init__(**kwa)
        self.keeper = keeper


    def enter(self):
        """"""
        self.keeper.reopen()


    def exit(self):
        """"""
        self.keeper.close()
